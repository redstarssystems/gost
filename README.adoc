== GOST library
:git:               https://git-scm.com[git]
:clojure-deps-cli:  https://clojure.org/guides/getting_started[clojure deps cli]
:tools-build:       https://clojure.org/guides/tools_build[tools-build]
:deps-new:          https://github.com/seancorfield/deps-new[deps-new]
:build-clj:         https://github.com/seancorfield/build-clj[build-clj]
:babashka:          https://github.com/babashka/babashka[babashka]
:toc:

== Intro

This is a thin wrapper for https://bouncycastle.org[Bouncycastle library] to work with GOST algorithms - Russian cryptographic standards.

The library provides:

- encryption, mac using _GOST 28147-89_, _GOST 3412-2015_;
- digest, hmac using _GOST3411-94/2012_ 256 and 512 bits;
- signature with _GOST3410-2001_, _GOST3410-2012_;
- key generation: secret keys, public/private keys, password based keys;
- high level functions:
** compression + encryption + mac / decryption + check mac + decompression
** encrypting with EC public keys / decrypting with EC private keys
** save / load keys (secret, private, public) to file.


This library is successor of https://github.com/middlesphere/crypto-gost[crypto-gost].

== Usage

Add dependency to the `deps.edn`:

[source,clojure]
----
:deps { org.rssys/gost {:mvn/version "0.1.0"}}
----

Require necessary namespaces:

[source,clojure]
----
(require '[org.rssys.gost.encrypt :as e])
(require '[org.rssys.gost.digest :as d])
(require '[org.rssys.gost.common :as common])
----

== Secret key generation

This is high-level functions.

[source, clojure]
----

;; To generate a secret key for the GOST3412-2015 use `generate-secret-key` function.
;; This will return a 256-bit random secret key as a SecretKeySpec object.
;; The algorithm is set to GOST3412-2015
(def secret-key-2015 (e/generate-secret-key))
(e/algo-name secret-key-2015) ;; => GOST3412-2015

;; To generate a secret key GOST28147-89 use `generate-secret-key` function with a parameter.
;; This will return a 256-bit random secret key as a SecretKeySpec object.
;; The algorithm is set to GOST28147.
(def secret-key-89 (e/generate-secret-key e/gost28147))
(e/algo-name secret-key-89) ;; => GOST28147

;; To convert a SecretKeySpec to a byte array:
(e/secret-key->byte-array secret-key-2015) ;; => [B
;; [-38, -86, 71, -42, -69, 73, -33, 53, 72, 80, 38, 26, 57, 69, -114, -1,
;; -119, 13, 113, -84, -31, 54, -128, 114, -79, -55, 85, 126, 105, -96,
;; -37, -128]

;; To convert a byte array to SecretKeySpec:
(e/byte-array->secret-key (byte-array [-38, -86, 71, -42, -69, 73, -33, 53, 72, 80, 38, 26, 57, 69, -114, -1,
                                       -119, 13, 113, -84, -31, 54, -128, 114, -79, -55, 85, 126, 105, -96,
                                       -37, -128])) ;; => #object[javax.crypto.spec.SecretKeySpec

;; We can generate a secret key bytes from a password.
;; This function always return the same bytes value from the same String password.
;; By default, it uses min 10000 iterations of PBKDF2WITHHMACGOST3411 algorithm, recommended by NIST
(e/generate-secret-bytes-from-password "qwerty12345") ;; => [B
;;[-113, 62, 87, -90, 116, -44, -20, -98, 4, -108, 77, -59, -22, 25, -73,
;; 20, -31, 62, -86, 19, 103, 81, -64, 32, 74, 81, -32, -97, -78, 123,
;; -82, -70]

;; To convert it to SecretKeySpec
(e/byte-array->secret-key
  (e/generate-secret-bytes-from-password "qwerty12345")) ;; => #object[javax.crypto.spec.SecretKeySpec

----

== Encryption

This is high-level functions.

[source,clojure]
----
(def message "This text has length = 32 bytes.")


;; To encrypt a byte array (any binary content) in a most secured way just use `protect-bytes` function.
;; The encryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; This function calculates Mac for plain data, then
;; compress a plain data to hide information structure, then
;; encrypts data and Mac in CFB mode with always random IV.
;; The encrypted bytes from the same message and same key are always different!
(def encrypted-message (e/protect-bytes secret-key-2015 (.getBytes message))) ;; Returns bytes array with structure:
;; [random(IV), encrypted(Mac), encrypted(compressed-data)]

;; To decrypt and restore a plain text just use `unprotect-bytes` function.
;; The decryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; This function decrypts Mac and data, then
;; decompress data, then calculate Mac for decompressed data, then
;; compare Mac from a message and Mac calculated.
;; If Macs are the same then return plain data, otherwise throw an Exception.
(def decrypted-message (e/unprotect-bytes secret-key-2015 encrypted-message))

(= message (String. ^bytes decrypted-message)) ;; => true

;; To encrypt a file (any binary content) in a most secured way just use `protect-file` function.
;; The encryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; This function calculates Mac for plain file, then
;; compress a plain file to hide information structure, then
;; encrypts data and Mac in CFB mode with always random IV.
;; The encrypted bytes from the same message and same key are always different!
(e/protect-file secret-key-2015 "dev/src/examples/plain32.txt" "target/plain32.enc") ;; Encrypted file has structure:
;; random(IV), encrypted(Mac), encrypted(compressed-data).

;; To decrypt a file just use `unprotect-file` function.
;; The decryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; This function decrypts Mac and data, then
;; decompress data in a file, then calculate Mac for decompressed data, then
;; compare Mac from the message and Mac calculated.
;; If Macs are the same then return output file name as String, otherwise throw an Exception.
(e/unprotect-file secret-key-2015 "target/plain32.enc" "target/plain32.txt")

(= (slurp "dev/src/examples/plain32.txt") (slurp "target/plain32.txt")) ;; => true

----

== Mac generation

This is high-level functions.

[source,clojure]
----
;; To calculate Mac for a file (any binary file) use `mac-stream` function.
;; The encryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; Mac value from the same data and same SecretKeySpec is always the same.
(e/mac-stream secret-key-2015 "dev/src/examples/plain32.txt") ;; => [B
;; [-111, 125, 10, -34, -109, -109, 41, 115, 81, 61, -90, -80, 16, 71, -108, 91]

;; To calculate Mac for a byte array (any binary file) use the same `mac-stream` function.
;; The encryption algorithm GOST3412-2015 or GOST28147-89 is already set in SecretKeySpec.
;; Mac value from the same data and same SecretKeySpec is always the same.
(e/mac-stream secret-key-2015 (.getBytes message)) ;; => [B
;; [-111, 125, 10, -34, -109, -109, 41, 115, 81, 61, -90, -80, 16, 71, -108, 91]

----

== Digest

This is high-level functions.

[source,clojure]
.digest.clj
----
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; High-level functions

(require '[org.rssys.gost.digest :as d])
(require '[org.rssys.gost.common :as common])

(def message "The quick brown fox jumps over the lazy dog")

;; To generate GOST3411-94 digest from byte array use `digest-3411-94` function
(def d1 (d/digest-3411-94 (.getBytes message)))

(common/bytes-to-hex d1)                                    ;; =>
;; "9004294a361a508c586fe53d1f1b02746765e71b765472786e4770d565830a76"

;; To generate GOST3411-94 digest from file use the same `digest-3411-94` function
(def d2 (d/digest-3411-94 "dev/src/examples/plain32.txt"))

(common/bytes-to-hex d2)                                    ;; =>
;; "94ca6fc62ae26d3bb0109c16e6a5749c291bbdd0cdf5231e3f4073679227b9fb"

;; To generate GOST3411-2012-256 digest from byte array use `digest-2012-256` function
(def d3 (d/digest-2012-256 (.getBytes message)))

(common/bytes-to-hex d3)                                    ;; =>
;; "3e7dea7f2384b6c5a3d0e24aaa29c05e89ddd762145030ec22c71a6db8b2c1f4"

;; To generate GOST3411-2012-256 digest from file use the same `GOST3411-2012-256` function
(def d4 (d/digest-2012-256 "dev/src/examples/plain32.txt"))

(common/bytes-to-hex d4)                                    ;; =>
;; "ee363d5e40c1ff1965ee308beef1ca153c1d56d377a63be29924731732f2c697"

;; To generate GOST3411-2012-512 digest from byte array use `digest-2012-512` function
(def d5 (d/digest-2012-512 (.getBytes message)))

(common/bytes-to-hex d5)                                    ;; =>
;; "d2b793a0bb6cb5904828b5b6dcfb443bb8f33efc06ad09368878ae4cdc8245b97e60802469bed1e7c21a64ff0b179a6a1e0bb74d92965450a0adab69162c00fe"

;; To generate GOST3411-2012-512 digest from file use the same `GOST3411-2012-512` function
(def d6 (d/digest-2012-512 "dev/src/examples/plain32.txt"))

(common/bytes-to-hex d6)                                    ;; =>
;; "7f75cf439c41420b25a3964ab0608af592c9af44e852dcbc18ae9fcfa0c2d7e3edda83715d23d30e5d3dc521290c66980695faa69adc7c5854ced01f0af6f0e9"

----

== HMAC

This is high-level functions.

[source,clojure]
.hmac.clj
----

(def message "The quick brown fox jumps over the lazy dog")

;; generate secret key from password
(def secret-key (e/generate-secret-bytes-from-password "12345678"))

;; Generate HMAC using GOST3411-94 and secret-key
(def h1 (d/hmac-3411-94 (.getBytes message) secret-key))

(common/bytes-to-hex h1)                                    ;; =>
;; "1ffb045ab775c674b5809d6f5c180c73be459223e93951e8c19cc1e0ed559b20"

;; Generate HMAC using GOST3411-2012-256 and secret-key
(def h2 (d/hmac-2012-256 (.getBytes message) secret-key))

(common/bytes-to-hex h2)                                    ;; =>
;; "405854baba2cc90661f1ff08e40c2cd0fb36869a5a32f655f51ea6fd577c6d84"

;; Generate HMAC using GOST3411-2012-512 and secret-key
(def h3 (d/hmac-2012-512 (.getBytes message) secret-key))

(common/bytes-to-hex h3)                                    ;; =>
;; "14923d761858aa272028855999c0bd3f37964e98bb3bb163825ecfbcd049e10f612566053031bec01611bc9584ef24aa80073cecc51d125fe989a973dd1f6813"

----



== Low-level functions

IMPORTANT: Use these functions carefully. +
*If you are not sure use high-level functions only!* 

=== IV & Mac length

[source,clojure]
----
;; IV length depends on encryption mode and algorithm
(e/iv-length-by-algo-mode e/gost3412-2015 :cfb-mode)        ;; => 16
(e/iv-length-by-algo-mode e/gost3412-2015 :cbc-mode)        ;; => 16
(e/iv-length-by-algo-mode e/gost3412-2015 :ctr-mode)        ;; => 8 !!

(e/iv-length-by-algo-mode e/gost28147 :cfb-mode)        ;; => 8
(e/iv-length-by-algo-mode e/gost28147 :cbc-mode)        ;; => 8
(e/iv-length-by-algo-mode e/gost28147 :ctr-mode)        ;; => 8

;; Mac length
(e/mac-length-by-algo e/gost3412-2015)                      ;; => 16
(e/mac-length-by-algo e/gost28147)                          ;; => 4

----

=== Encryption modes

*This is for low-level functions.*

Available encryption modes for _GOST3412-2015_:

- `:cfb-mode` is "GOST3412-2015/CFB/NoPadding"
- `:ctr-mode` is "GOST3412-2015/CTR/NoPadding"
- `:cbc-mode` is "GOST3412-2015/CBC/PKCS7Padding"

Available encryption modes for _GOST28147_:

- `:cfb-mode` is "GOST28147/CFB/NoPadding"
- `:ctr-mode` is "GOST28147/CTR/NoPadding"
- `:cbc-mode` is "GOST28147/CBC/PKCS7Padding"

==== Init Cipher Mode

[source,clojure]
----
;; Init Cipher for GOST28147 in CFB, CTR, CBC mode
(def cipher1 (e/init-cipher-mode e/gost28147 :cfb-mode))
(def cipher2 (e/init-cipher-mode e/gost28147 :ctr-mode))
(def cipher3 (e/init-cipher-mode e/gost28147 :cbc-mode))

;; Init Cipher for GOST3412-2015 in CFB, CTR, CBC mode
(def cipher4 (e/init-cipher-mode e/gost3412-2015 :cfb-mode))
(def cipher5 (e/init-cipher-mode e/gost3412-2015 :ctr-mode))
(def cipher6 (e/init-cipher-mode e/gost3412-2015 :cbc-mode))
----


=== Create random IV

*This is low-level functions.*

[source,clojure]
----
;; Random IV generation

(e/new-iv-8)                                                ;; => [B
;; [25, 117, -36, -32, -87, -128, -25, 23]

(e/new-iv-16)                                               ;;=> [B
;; [29, -49, 83, 120, -125, 95, 41, -54, -11, -37, -2, -19, 123, -122,
;; -21, 6]

;; Also we can generate IV depend on cipher mode and algorithm name
(e/new-iv e/gost28147 :cfb-mode)                            ;; => [B
;; [-101, 29, 29, 55, 112, 14, 55, 104]

(e/new-iv e/gost3412-2015 :cbc-mode)                        ;; => [B
;; [6, 87, 96, -83, -128, 25, -57, -70, -54, 51, 9, -26, 73, -103, 64, 67]

;; Warning! IV for :ctr-mode is always 8 bytes length for any algorithm
(e/new-iv e/gost3412-2015 :ctr-mode)                        ;; => [B => [45, -71, 116, -67, 9, -39, -101, -51]
(e/new-iv e/gost28147 :ctr-mode)                            ;; => [B => [8, 39, -126, -5, 122, -120, 1, -108]

----

=== Init Cipher

*This is low-level functions.*

==== GOST named parameters

The GOST28147-89 has several named `S-box` parameters:

- *"E-A"*     - _Gost28147_89_CryptoPro_A_ParamSet_ (most used); +
- *"E-B"*     - _Gost28147_89_CryptoPro_B_ParamSet_ (most used); +
- *"E-C"*     - _Gost28147_89_CryptoPro_C_ParamSet_; +
- *"E-D"*     - _Gost28147_89_CryptoPro_D_ParamSet_; +
- *"Param-Z"* - _tc26_gost_28147_param_Z_.

[source,clojure]
----
(def secret-key (e/generate-secret-key e/gost28147))        ;; generate secret key
(def iv-8 (e/new-iv (e/algo-name secret-key) :cfb-mode))      ;; generate new random IV
(def algo-param-spec (e/init-gost-named-params (e/algo-name secret-key) iv-8 "E-A")) ;; Init GOST with "E-A" parameters
----

==== GOST OID parameters

The GOST28147-89 has several OID `S-box` parameters 
https://cpdn.cryptopro.ru/content/csp40/html/group___pro_c_s_p_ex_CP_PARAM_OIDS.html[OID params table]

[source,clojure]
----
;; Init GOST with OID parameters
;; See https://cpdn.cryptopro.ru/content/csp40/html/group___pro_c_s_p_ex_CP_PARAM_OIDS.html
(e/init-gost-oid-params e/gost28147 iv-8 (org.bouncycastle.asn1.ASN1ObjectIdentifier. "1.2.643.2.2.31.1"))
----

==== GOST binary S-box parameters

The GOST28147-89 may be initialized with 'S-boxes' as bytes array:

[source,clojure]
----
;; Init GOST 28147 with S-box as binary array
;; https://datatracker.ietf.org/doc/html/rfc4357
;; id-Gost28147-89-CryptoPro-A-ParamSet
(def ^:const s-box-crypto-pro-a
  [9 6 3 2 8 11 1 7 10 4 14 15 12 0 13 5
   3 7 14 9 8 10 15 0 5 2 6 12 11 4 13 1
   14 4 6 2 11 3 13 8 12 15 5 10 0 7 1 9
   14 7 10 12 13 1 3 9 0 2 11 4 15 8 5 6
   11 5 1 9 8 13 15 0 14 4 2 3 12 7 10 6
   3 10 13 12 1 2 0 11 7 5 9 4 8 15 14 6
   1 13 2 9 7 10 6 0 8 12 4 5 15 3 11 14
   11 10 15 5 0 12 14 8 6 2 3 9 1 7 13 4])

(e/init-gost-sbox-binary-params e/gost28147 iv-8 (byte-array s-box-crypto-pro-a))
----


==== Encryption mode

*The `new-encryption-cipher` is a low-level function.*

[source,clojure]
----
;; Init cipher for GOST3412-2015,  generate random IV automatically
(def cipher-2015 (e/new-encryption-cipher secret-key-2015 :cfb-mode))
;; extract IV
(.getIV cipher-2015)                                             ;; => [B
;;[105, 13, 115, 71, 2, -23, 6, 82, -30, -13, 113, -12, -34, 69, -6, 27]

;; Init cipher for GOST28147,  generate random IV automatically
(def cipher-89 (e/new-encryption-cipher secret-key-89 :cfb-mode))
;; extract IV
(.getIV cipher-89) ;; => [-84, -116, -60, -99, 89, 43, -107, 127]


;; Init cipher for GOST3412-2015,  with AlgoParamsSpec, IV should be always random
(def cipher-2015 (e/new-encryption-cipher secret-key-2015 :cfb-mode 
                   (javax.crypto.spec.IvParameterSpec. (e/new-iv-16))))

;; Init cipher for GOST28147,  with AlgoParamsSpec, IV should be always random
(def cipher-89 (e/new-encryption-cipher secret-key-89 :cfb-mode
                 (e/init-gost-named-params (e/algo-name secret-key-89) (e/new-iv-8) "E-A")))
----


==== Decryption mode

*The `new-decryption-cipher` is a low-level function.*

[source,clojure]
----
;; Init decryption cipher for GOST3412-2015
(def iv-16 (.getIV cipher-2015))            ;; we should use the same IV which was used in encryption phase
(def decryption-cipher-2015 (e/new-decryption-cipher secret-key-2015 :cfb-mode
                              (javax.crypto.spec.IvParameterSpec. iv-16)))

;; Init decryption cipher for GOST28147
;; we should use the same IV and S-boxes which were used in encryption phase
(def iv-8 (.getIV cipher-89)) 
(def decryption-cipher-89 (e/new-decryption-cipher secret-key-89 :cfb-mode
                            (e/init-gost-named-params (e/algo-name secret-key-89) iv-8 "E-A")))


----

==== Encryption/Decryption

*This is low-level functions.*

[source,clojure]
.enc.clj
----
;; Init cipher for GOST3412-2015,  generate random IV automatically
(def cipher-2015 (e/new-encryption-cipher secret-key-2015 :cfb-mode))
(def iv-16 (.getIV cipher-2015))
(def decryption-cipher-2015 (e/new-decryption-cipher secret-key-2015 :cfb-mode (javax.crypto.spec.IvParameterSpec. iv-16)))

;; To encrypt bytes use `encrypt-bytes` function and Cipher initialized with
;; secret key and random IV in encryption mode
(def e1 (e/encrypt-bytes cipher-2015 (.getBytes message)))  ;; => [B
;;[79, 67, 111, -67, 4, 99, 92, -68, 66, -35, 77, -6, 115, 56, 108, 47,
;; -124, -82, 107, -18, -95, -125, -18, 106, -53, -21, 0, -108, -48, 41,
;; -86, -84]

;; Remember, you should know IV which was used during encryption to decrypt it.

;; To decrypt bytes use `decrypt-bytes` function and Cipher initialized with
;; the same secret key and the same IV in decryption mode
(String. ^bytes (e/decrypt-bytes decryption-cipher-2015 e1)) ;; => "This text has length = 32 bytes."


;; To encrypt file use `encrypt-stream` function and Cipher initialized with
;; secret key and random IV in encryption mode
(e/encrypt-stream cipher-2015 "dev/src/examples/plain32.txt" "target/plain32.enc")


;; Remember, you should know IV which was used during encryption to decrypt it.

;; To decrypt file use `decrypt-stream` function and Cipher initialized with
;; the same secret key and the same IV in decryption mode
(e/decrypt-stream decryption-cipher-2015 "target/plain32.enc" "target/plain32.txt") ;; => "This text has length = 32 bytes."

(slurp "target/plain32.txt") ;; => "This text has length = 32 bytes."

----


==== Compression / Decompression

*This is low-level functions.*

[source,clojure]
.comp-decomp.clj
----
;; To compress plain bytes to hide its internal structure before encryption use `compress-bytes` function
(def cb (e/compress-bytes (.getBytes message)))                    ;; => [B
;;[120, -38, 11, -55, -56, 44, 86, 40, 73, -83, 40, 81, -56, 72, 44, 86,
;; -56, 73, -51, 75, 47, -55, 80, -80, 85, 48, 54, 82, 72, -86, 44, 73,
;; 45, -42, 3, 0, -71, 112, 10, -45]

;; To decompress plain bytes use `decompress-bytes` function
(String. (e/decompress-bytes cb))                   ;; => "This text has length = 32 bytes."

;; To compress file to hide its internal structure before encryption use `compress-stream` function
(e/compress-stream "dev/src/examples/plain32.txt" "target/plain32.gz")

;; To decompress file use `decompress-stream` function
(e/decompress-stream "target/plain32.gz" "target/plain32.txt")

(slurp "target/plain32.txt") ;; => "This text has length = 32 bytes."

----

==== Compression+Encryption / Decryption + Decompression

*This is low-level functions.*

[source,clojure]
.comp-e.clj
----
;; Init cipher for GOST3412-2015,  generate random IV automatically
(def cipher-2015 (e/new-encryption-cipher secret-key-2015 :cfb-mode))
(def iv-16 (.getIV cipher-2015))
(def decryption-cipher-2015 (e/new-decryption-cipher secret-key-2015 :cfb-mode (javax.crypto.spec.IvParameterSpec. iv-16)))

(def baos (ByteArrayOutputStream.))


;; To compress  and encrypt plain bytes use `compress-and-encrypt-stream` function
(e/compress-and-encrypt-stream cipher-2015 (.getBytes message) baos)
(def ceb (.toByteArray baos)) ;; => [B
;;[-14, -43, -92, -4, -79, 85, 72, -50, 77, -102, -24, 21, -119, 81,
;; -100, -98, 39, -79, -56, 61, -95, 118, 28, -126, 39, -65, 10, -15, 21,
;; -33, 23, -44, 60, 52, 76, 35, 69, 119, -96, 50]

(def baosd (ByteArrayOutputStream.))

;; Remember, you should know IV which was used during encryption to decrypt it.

;; To decompress and decrypt use `decrypt-and-decompress-stream` function
(e/decrypt-and-decompress-stream decryption-cipher-2015 ceb baosd)
(String. (.toByteArray baosd)) ;; => "This text has length = 32 bytes."

;; To compress and encrypt file  use `compress-and-encrypt-stream` function
(e/compress-and-encrypt-stream cipher-2015 "dev/src/examples/plain32.txt" "target/plain32.egz")

;; Remember, you should know IV which was used during encryption to decrypt it.

;; To decompress and decrypt file use `decrypt-and-decompress-stream` function
(e/decrypt-and-decompress-stream decryption-cipher-2015 "target/plain32.egz" "target/plain32.txt")

(slurp "target/plain32.txt") ;; => "This text has length = 32 bytes."

----



== Build this project

Project org.rssys/gost generated from https://github.com/redstarssystems/libtemplate[Library template].

[#install-prerequisites]
=== Install prerequisites

All these tools you need to install only once.

. Install {clojure-deps-cli} tools version 1.10.3.1069+
.. MacOS
+
[source,bash]
----
brew install clojure/tools/clojure
----
.. Linux
+
Ensure that the following dependencies are installed in OS: `bash`, `curl`, `rlwrap`, and `Java`.
+
[source, bash]
----
curl -O https://download.clojure.org/install/linux-install-1.10.3.1069.sh
chmod +x linux-install-1.10.3.1069.sh
sudo ./linux-install-1.10.3.1069.sh
----

. Install latest {deps-new}
+
[source,bash]
----
clojure -Ttools install io.github.seancorfield/deps-new '{:git/tag "v0.4.9"}' :as new
----
+
Tool will be installed in `~/.gitlibs/libs/`

. Install {babashka} v0.4.0+
.. MacOS
+
[source, bash]
----
brew install borkdude/brew/babashka
----
+
.. Linux
+
[source, bash]
----
sudo bash < <(curl -s https://raw.githubusercontent.com/babashka/babashka/master/install)
----

. Run once:
+
[source,bash]
----
bb requirements
----
to install other necessary tools (MacOS only, for Linux manual instruction).

=== Project workflow

To configure project workflow scripts use `bb.edn` and `build.clj` files.

Run `bb tasks` to show help for project workflow. The following tasks are available:

[source, bash]
----
clean        Clean target folder
build        Build deployable jar file for this project
install      Install deployable jar locally (requires the pom.xml file)
deploy       Deploy this library to Clojars
test         Run tests
repl         Run Clojure repl
outdated     Check for outdated dependencies
outdated:fix Check for outdated dependencies and fix
format       Format source code
lint         Lint source code
requirements Install project requirements
----

== License

Copyright © 2022 Mike Ananev +
Distributed under the Eclipse Public License 1.0 or (at your option) any later version.
